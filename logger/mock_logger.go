// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package logger

import (
	"github.com/DataDog/datadog-go/statsd"
	"github.com/hashicorp/go-hclog"
	"github.com/nicholasjackson/pipe/pipe"
	"github.com/nicholasjackson/pipe/providers"
	"sync"
)

var (
	lockLoggerMockGetLogger                     sync.RWMutex
	lockLoggerMockGetStatsD                     sync.RWMutex
	lockLoggerMockProviderConnectionCreated     sync.RWMutex
	lockLoggerMockProviderConnectionFailed      sync.RWMutex
	lockLoggerMockProviderMessagePublished      sync.RWMutex
	lockLoggerMockProviderSubcriptionCreated    sync.RWMutex
	lockLoggerMockProviderSubcriptionFailed     sync.RWMutex
	lockLoggerMockServerActionPublish           sync.RWMutex
	lockLoggerMockServerActionPublishFailed     sync.RWMutex
	lockLoggerMockServerActionPublishSuccess    sync.RWMutex
	lockLoggerMockServerFailPublish             sync.RWMutex
	lockLoggerMockServerFailPublishFailed       sync.RWMutex
	lockLoggerMockServerFailPublishSuccess      sync.RWMutex
	lockLoggerMockServerHandleMessageExpired    sync.RWMutex
	lockLoggerMockServerNewMessageReceivedStart sync.RWMutex
	lockLoggerMockServerNoPipesConfigured       sync.RWMutex
	lockLoggerMockServerSuccessPublish          sync.RWMutex
	lockLoggerMockServerSuccessPublishFailed    sync.RWMutex
	lockLoggerMockServerSuccessPublishSuccess   sync.RWMutex
	lockLoggerMockServerTemplateProcessFail     sync.RWMutex
	lockLoggerMockServerTemplateProcessStart    sync.RWMutex
	lockLoggerMockServerTemplateProcessSuccess  sync.RWMutex
	lockLoggerMockServerUnableToListen          sync.RWMutex
)

// LoggerMock is a mock implementation of Logger.
//
//     func TestSomethingThatUsesLogger(t *testing.T) {
//
//         // make and configure a mocked Logger
//         mockedLogger := &LoggerMock{
//             GetLoggerFunc: func() hclog.Logger {
// 	               panic("TODO: mock out the GetLogger method")
//             },
//             GetStatsDFunc: func() *statsd.Client {
// 	               panic("TODO: mock out the GetStatsD method")
//             },
//             ProviderConnectionCreatedFunc: func(in1 providers.Provider)  {
// 	               panic("TODO: mock out the ProviderConnectionCreated method")
//             },
//             ProviderConnectionFailedFunc: func(in1 providers.Provider, in2 error)  {
// 	               panic("TODO: mock out the ProviderConnectionFailed method")
//             },
//             ProviderMessagePublishedFunc: func(in1 providers.Provider, in2 *providers.Message)  {
// 	               panic("TODO: mock out the ProviderMessagePublished method")
//             },
//             ProviderSubcriptionCreatedFunc: func(in1 providers.Provider)  {
// 	               panic("TODO: mock out the ProviderSubcriptionCreated method")
//             },
//             ProviderSubcriptionFailedFunc: func(in1 providers.Provider, in2 error)  {
// 	               panic("TODO: mock out the ProviderSubcriptionFailed method")
//             },
//             ServerActionPublishFunc: func(in1 *pipe.Pipe, in2 *providers.Message)  {
// 	               panic("TODO: mock out the ServerActionPublish method")
//             },
//             ServerActionPublishFailedFunc: func(in1 *pipe.Pipe, in2 *providers.Message, in3 error)  {
// 	               panic("TODO: mock out the ServerActionPublishFailed method")
//             },
//             ServerActionPublishSuccessFunc: func(in1 *pipe.Pipe, in2 *providers.Message)  {
// 	               panic("TODO: mock out the ServerActionPublishSuccess method")
//             },
//             ServerFailPublishFunc: func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message)  {
// 	               panic("TODO: mock out the ServerFailPublish method")
//             },
//             ServerFailPublishFailedFunc: func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message, in4 error)  {
// 	               panic("TODO: mock out the ServerFailPublishFailed method")
//             },
//             ServerFailPublishSuccessFunc: func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message)  {
// 	               panic("TODO: mock out the ServerFailPublishSuccess method")
//             },
//             ServerHandleMessageExpiredFunc: func(in1 *pipe.Pipe, in2 *providers.Message)  {
// 	               panic("TODO: mock out the ServerHandleMessageExpired method")
//             },
//             ServerNewMessageReceivedStartFunc: func(in1 *pipe.Pipe, in2 *providers.Message) *LoggerTiming {
// 	               panic("TODO: mock out the ServerNewMessageReceivedStart method")
//             },
//             ServerNoPipesConfiguredFunc: func(in1 providers.Provider)  {
// 	               panic("TODO: mock out the ServerNoPipesConfigured method")
//             },
//             ServerSuccessPublishFunc: func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message)  {
// 	               panic("TODO: mock out the ServerSuccessPublish method")
//             },
//             ServerSuccessPublishFailedFunc: func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message, in4 error)  {
// 	               panic("TODO: mock out the ServerSuccessPublishFailed method")
//             },
//             ServerSuccessPublishSuccessFunc: func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message)  {
// 	               panic("TODO: mock out the ServerSuccessPublishSuccess method")
//             },
//             ServerTemplateProcessFailFunc: func(in1 *pipe.Action, in2 []byte, in3 error)  {
// 	               panic("TODO: mock out the ServerTemplateProcessFail method")
//             },
//             ServerTemplateProcessStartFunc: func(in1 *pipe.Action, in2 []byte) *LoggerTiming {
// 	               panic("TODO: mock out the ServerTemplateProcessStart method")
//             },
//             ServerTemplateProcessSuccessFunc: func(in1 *pipe.Action, in2 []byte)  {
// 	               panic("TODO: mock out the ServerTemplateProcessSuccess method")
//             },
//             ServerUnableToListenFunc: func(in1 providers.Provider, in2 error)  {
// 	               panic("TODO: mock out the ServerUnableToListen method")
//             },
//         }
//
//         // TODO: use mockedLogger in code that requires Logger
//         //       and then make assertions.
//
//     }
type LoggerMock struct {
	// GetLoggerFunc mocks the GetLogger method.
	GetLoggerFunc func() hclog.Logger

	// GetStatsDFunc mocks the GetStatsD method.
	GetStatsDFunc func() *statsd.Client

	// ProviderConnectionCreatedFunc mocks the ProviderConnectionCreated method.
	ProviderConnectionCreatedFunc func(in1 providers.Provider)

	// ProviderConnectionFailedFunc mocks the ProviderConnectionFailed method.
	ProviderConnectionFailedFunc func(in1 providers.Provider, in2 error)

	// ProviderMessagePublishedFunc mocks the ProviderMessagePublished method.
	ProviderMessagePublishedFunc func(in1 providers.Provider, in2 *providers.Message)

	// ProviderSubcriptionCreatedFunc mocks the ProviderSubcriptionCreated method.
	ProviderSubcriptionCreatedFunc func(in1 providers.Provider)

	// ProviderSubcriptionFailedFunc mocks the ProviderSubcriptionFailed method.
	ProviderSubcriptionFailedFunc func(in1 providers.Provider, in2 error)

	// ServerActionPublishFunc mocks the ServerActionPublish method.
	ServerActionPublishFunc func(in1 *pipe.Pipe, in2 *providers.Message)

	// ServerActionPublishFailedFunc mocks the ServerActionPublishFailed method.
	ServerActionPublishFailedFunc func(in1 *pipe.Pipe, in2 *providers.Message, in3 error)

	// ServerActionPublishSuccessFunc mocks the ServerActionPublishSuccess method.
	ServerActionPublishSuccessFunc func(in1 *pipe.Pipe, in2 *providers.Message)

	// ServerFailPublishFunc mocks the ServerFailPublish method.
	ServerFailPublishFunc func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message)

	// ServerFailPublishFailedFunc mocks the ServerFailPublishFailed method.
	ServerFailPublishFailedFunc func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message, in4 error)

	// ServerFailPublishSuccessFunc mocks the ServerFailPublishSuccess method.
	ServerFailPublishSuccessFunc func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message)

	// ServerHandleMessageExpiredFunc mocks the ServerHandleMessageExpired method.
	ServerHandleMessageExpiredFunc func(in1 *pipe.Pipe, in2 *providers.Message)

	// ServerNewMessageReceivedStartFunc mocks the ServerNewMessageReceivedStart method.
	ServerNewMessageReceivedStartFunc func(in1 *pipe.Pipe, in2 *providers.Message) *LoggerTiming

	// ServerNoPipesConfiguredFunc mocks the ServerNoPipesConfigured method.
	ServerNoPipesConfiguredFunc func(in1 providers.Provider)

	// ServerSuccessPublishFunc mocks the ServerSuccessPublish method.
	ServerSuccessPublishFunc func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message)

	// ServerSuccessPublishFailedFunc mocks the ServerSuccessPublishFailed method.
	ServerSuccessPublishFailedFunc func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message, in4 error)

	// ServerSuccessPublishSuccessFunc mocks the ServerSuccessPublishSuccess method.
	ServerSuccessPublishSuccessFunc func(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message)

	// ServerTemplateProcessFailFunc mocks the ServerTemplateProcessFail method.
	ServerTemplateProcessFailFunc func(in1 *pipe.Action, in2 []byte, in3 error)

	// ServerTemplateProcessStartFunc mocks the ServerTemplateProcessStart method.
	ServerTemplateProcessStartFunc func(in1 *pipe.Action, in2 []byte) *LoggerTiming

	// ServerTemplateProcessSuccessFunc mocks the ServerTemplateProcessSuccess method.
	ServerTemplateProcessSuccessFunc func(in1 *pipe.Action, in2 []byte)

	// ServerUnableToListenFunc mocks the ServerUnableToListen method.
	ServerUnableToListenFunc func(in1 providers.Provider, in2 error)

	// calls tracks calls to the methods.
	calls struct {
		// GetLogger holds details about calls to the GetLogger method.
		GetLogger []struct {
		}
		// GetStatsD holds details about calls to the GetStatsD method.
		GetStatsD []struct {
		}
		// ProviderConnectionCreated holds details about calls to the ProviderConnectionCreated method.
		ProviderConnectionCreated []struct {
			// In1 is the in1 argument value.
			In1 providers.Provider
		}
		// ProviderConnectionFailed holds details about calls to the ProviderConnectionFailed method.
		ProviderConnectionFailed []struct {
			// In1 is the in1 argument value.
			In1 providers.Provider
			// In2 is the in2 argument value.
			In2 error
		}
		// ProviderMessagePublished holds details about calls to the ProviderMessagePublished method.
		ProviderMessagePublished []struct {
			// In1 is the in1 argument value.
			In1 providers.Provider
			// In2 is the in2 argument value.
			In2 *providers.Message
		}
		// ProviderSubcriptionCreated holds details about calls to the ProviderSubcriptionCreated method.
		ProviderSubcriptionCreated []struct {
			// In1 is the in1 argument value.
			In1 providers.Provider
		}
		// ProviderSubcriptionFailed holds details about calls to the ProviderSubcriptionFailed method.
		ProviderSubcriptionFailed []struct {
			// In1 is the in1 argument value.
			In1 providers.Provider
			// In2 is the in2 argument value.
			In2 error
		}
		// ServerActionPublish holds details about calls to the ServerActionPublish method.
		ServerActionPublish []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *providers.Message
		}
		// ServerActionPublishFailed holds details about calls to the ServerActionPublishFailed method.
		ServerActionPublishFailed []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *providers.Message
			// In3 is the in3 argument value.
			In3 error
		}
		// ServerActionPublishSuccess holds details about calls to the ServerActionPublishSuccess method.
		ServerActionPublishSuccess []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *providers.Message
		}
		// ServerFailPublish holds details about calls to the ServerFailPublish method.
		ServerFailPublish []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *pipe.Action
			// In3 is the in3 argument value.
			In3 *providers.Message
		}
		// ServerFailPublishFailed holds details about calls to the ServerFailPublishFailed method.
		ServerFailPublishFailed []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *pipe.Action
			// In3 is the in3 argument value.
			In3 *providers.Message
			// In4 is the in4 argument value.
			In4 error
		}
		// ServerFailPublishSuccess holds details about calls to the ServerFailPublishSuccess method.
		ServerFailPublishSuccess []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *pipe.Action
			// In3 is the in3 argument value.
			In3 *providers.Message
		}
		// ServerHandleMessageExpired holds details about calls to the ServerHandleMessageExpired method.
		ServerHandleMessageExpired []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *providers.Message
		}
		// ServerNewMessageReceivedStart holds details about calls to the ServerNewMessageReceivedStart method.
		ServerNewMessageReceivedStart []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *providers.Message
		}
		// ServerNoPipesConfigured holds details about calls to the ServerNoPipesConfigured method.
		ServerNoPipesConfigured []struct {
			// In1 is the in1 argument value.
			In1 providers.Provider
		}
		// ServerSuccessPublish holds details about calls to the ServerSuccessPublish method.
		ServerSuccessPublish []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *pipe.Action
			// In3 is the in3 argument value.
			In3 *providers.Message
		}
		// ServerSuccessPublishFailed holds details about calls to the ServerSuccessPublishFailed method.
		ServerSuccessPublishFailed []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *pipe.Action
			// In3 is the in3 argument value.
			In3 *providers.Message
			// In4 is the in4 argument value.
			In4 error
		}
		// ServerSuccessPublishSuccess holds details about calls to the ServerSuccessPublishSuccess method.
		ServerSuccessPublishSuccess []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Pipe
			// In2 is the in2 argument value.
			In2 *pipe.Action
			// In3 is the in3 argument value.
			In3 *providers.Message
		}
		// ServerTemplateProcessFail holds details about calls to the ServerTemplateProcessFail method.
		ServerTemplateProcessFail []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Action
			// In2 is the in2 argument value.
			In2 []byte
			// In3 is the in3 argument value.
			In3 error
		}
		// ServerTemplateProcessStart holds details about calls to the ServerTemplateProcessStart method.
		ServerTemplateProcessStart []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Action
			// In2 is the in2 argument value.
			In2 []byte
		}
		// ServerTemplateProcessSuccess holds details about calls to the ServerTemplateProcessSuccess method.
		ServerTemplateProcessSuccess []struct {
			// In1 is the in1 argument value.
			In1 *pipe.Action
			// In2 is the in2 argument value.
			In2 []byte
		}
		// ServerUnableToListen holds details about calls to the ServerUnableToListen method.
		ServerUnableToListen []struct {
			// In1 is the in1 argument value.
			In1 providers.Provider
			// In2 is the in2 argument value.
			In2 error
		}
	}
}

// GetLogger calls GetLoggerFunc.
func (mock *LoggerMock) GetLogger() hclog.Logger {
	if mock.GetLoggerFunc == nil {
		panic("moq: LoggerMock.GetLoggerFunc is nil but Logger.GetLogger was just called")
	}
	callInfo := struct {
	}{}
	lockLoggerMockGetLogger.Lock()
	mock.calls.GetLogger = append(mock.calls.GetLogger, callInfo)
	lockLoggerMockGetLogger.Unlock()
	return mock.GetLoggerFunc()
}

// GetLoggerCalls gets all the calls that were made to GetLogger.
// Check the length with:
//     len(mockedLogger.GetLoggerCalls())
func (mock *LoggerMock) GetLoggerCalls() []struct {
} {
	var calls []struct {
	}
	lockLoggerMockGetLogger.RLock()
	calls = mock.calls.GetLogger
	lockLoggerMockGetLogger.RUnlock()
	return calls
}

// GetStatsD calls GetStatsDFunc.
func (mock *LoggerMock) GetStatsD() *statsd.Client {
	if mock.GetStatsDFunc == nil {
		panic("moq: LoggerMock.GetStatsDFunc is nil but Logger.GetStatsD was just called")
	}
	callInfo := struct {
	}{}
	lockLoggerMockGetStatsD.Lock()
	mock.calls.GetStatsD = append(mock.calls.GetStatsD, callInfo)
	lockLoggerMockGetStatsD.Unlock()
	return mock.GetStatsDFunc()
}

// GetStatsDCalls gets all the calls that were made to GetStatsD.
// Check the length with:
//     len(mockedLogger.GetStatsDCalls())
func (mock *LoggerMock) GetStatsDCalls() []struct {
} {
	var calls []struct {
	}
	lockLoggerMockGetStatsD.RLock()
	calls = mock.calls.GetStatsD
	lockLoggerMockGetStatsD.RUnlock()
	return calls
}

// ProviderConnectionCreated calls ProviderConnectionCreatedFunc.
func (mock *LoggerMock) ProviderConnectionCreated(in1 providers.Provider) {
	if mock.ProviderConnectionCreatedFunc == nil {
		panic("moq: LoggerMock.ProviderConnectionCreatedFunc is nil but Logger.ProviderConnectionCreated was just called")
	}
	callInfo := struct {
		In1 providers.Provider
	}{
		In1: in1,
	}
	lockLoggerMockProviderConnectionCreated.Lock()
	mock.calls.ProviderConnectionCreated = append(mock.calls.ProviderConnectionCreated, callInfo)
	lockLoggerMockProviderConnectionCreated.Unlock()
	mock.ProviderConnectionCreatedFunc(in1)
}

// ProviderConnectionCreatedCalls gets all the calls that were made to ProviderConnectionCreated.
// Check the length with:
//     len(mockedLogger.ProviderConnectionCreatedCalls())
func (mock *LoggerMock) ProviderConnectionCreatedCalls() []struct {
	In1 providers.Provider
} {
	var calls []struct {
		In1 providers.Provider
	}
	lockLoggerMockProviderConnectionCreated.RLock()
	calls = mock.calls.ProviderConnectionCreated
	lockLoggerMockProviderConnectionCreated.RUnlock()
	return calls
}

// ProviderConnectionFailed calls ProviderConnectionFailedFunc.
func (mock *LoggerMock) ProviderConnectionFailed(in1 providers.Provider, in2 error) {
	if mock.ProviderConnectionFailedFunc == nil {
		panic("moq: LoggerMock.ProviderConnectionFailedFunc is nil but Logger.ProviderConnectionFailed was just called")
	}
	callInfo := struct {
		In1 providers.Provider
		In2 error
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockProviderConnectionFailed.Lock()
	mock.calls.ProviderConnectionFailed = append(mock.calls.ProviderConnectionFailed, callInfo)
	lockLoggerMockProviderConnectionFailed.Unlock()
	mock.ProviderConnectionFailedFunc(in1, in2)
}

// ProviderConnectionFailedCalls gets all the calls that were made to ProviderConnectionFailed.
// Check the length with:
//     len(mockedLogger.ProviderConnectionFailedCalls())
func (mock *LoggerMock) ProviderConnectionFailedCalls() []struct {
	In1 providers.Provider
	In2 error
} {
	var calls []struct {
		In1 providers.Provider
		In2 error
	}
	lockLoggerMockProviderConnectionFailed.RLock()
	calls = mock.calls.ProviderConnectionFailed
	lockLoggerMockProviderConnectionFailed.RUnlock()
	return calls
}

// ProviderMessagePublished calls ProviderMessagePublishedFunc.
func (mock *LoggerMock) ProviderMessagePublished(in1 providers.Provider, in2 *providers.Message) {
	if mock.ProviderMessagePublishedFunc == nil {
		panic("moq: LoggerMock.ProviderMessagePublishedFunc is nil but Logger.ProviderMessagePublished was just called")
	}
	callInfo := struct {
		In1 providers.Provider
		In2 *providers.Message
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockProviderMessagePublished.Lock()
	mock.calls.ProviderMessagePublished = append(mock.calls.ProviderMessagePublished, callInfo)
	lockLoggerMockProviderMessagePublished.Unlock()
	mock.ProviderMessagePublishedFunc(in1, in2)
}

// ProviderMessagePublishedCalls gets all the calls that were made to ProviderMessagePublished.
// Check the length with:
//     len(mockedLogger.ProviderMessagePublishedCalls())
func (mock *LoggerMock) ProviderMessagePublishedCalls() []struct {
	In1 providers.Provider
	In2 *providers.Message
} {
	var calls []struct {
		In1 providers.Provider
		In2 *providers.Message
	}
	lockLoggerMockProviderMessagePublished.RLock()
	calls = mock.calls.ProviderMessagePublished
	lockLoggerMockProviderMessagePublished.RUnlock()
	return calls
}

// ProviderSubcriptionCreated calls ProviderSubcriptionCreatedFunc.
func (mock *LoggerMock) ProviderSubcriptionCreated(in1 providers.Provider) {
	if mock.ProviderSubcriptionCreatedFunc == nil {
		panic("moq: LoggerMock.ProviderSubcriptionCreatedFunc is nil but Logger.ProviderSubcriptionCreated was just called")
	}
	callInfo := struct {
		In1 providers.Provider
	}{
		In1: in1,
	}
	lockLoggerMockProviderSubcriptionCreated.Lock()
	mock.calls.ProviderSubcriptionCreated = append(mock.calls.ProviderSubcriptionCreated, callInfo)
	lockLoggerMockProviderSubcriptionCreated.Unlock()
	mock.ProviderSubcriptionCreatedFunc(in1)
}

// ProviderSubcriptionCreatedCalls gets all the calls that were made to ProviderSubcriptionCreated.
// Check the length with:
//     len(mockedLogger.ProviderSubcriptionCreatedCalls())
func (mock *LoggerMock) ProviderSubcriptionCreatedCalls() []struct {
	In1 providers.Provider
} {
	var calls []struct {
		In1 providers.Provider
	}
	lockLoggerMockProviderSubcriptionCreated.RLock()
	calls = mock.calls.ProviderSubcriptionCreated
	lockLoggerMockProviderSubcriptionCreated.RUnlock()
	return calls
}

// ProviderSubcriptionFailed calls ProviderSubcriptionFailedFunc.
func (mock *LoggerMock) ProviderSubcriptionFailed(in1 providers.Provider, in2 error) {
	if mock.ProviderSubcriptionFailedFunc == nil {
		panic("moq: LoggerMock.ProviderSubcriptionFailedFunc is nil but Logger.ProviderSubcriptionFailed was just called")
	}
	callInfo := struct {
		In1 providers.Provider
		In2 error
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockProviderSubcriptionFailed.Lock()
	mock.calls.ProviderSubcriptionFailed = append(mock.calls.ProviderSubcriptionFailed, callInfo)
	lockLoggerMockProviderSubcriptionFailed.Unlock()
	mock.ProviderSubcriptionFailedFunc(in1, in2)
}

// ProviderSubcriptionFailedCalls gets all the calls that were made to ProviderSubcriptionFailed.
// Check the length with:
//     len(mockedLogger.ProviderSubcriptionFailedCalls())
func (mock *LoggerMock) ProviderSubcriptionFailedCalls() []struct {
	In1 providers.Provider
	In2 error
} {
	var calls []struct {
		In1 providers.Provider
		In2 error
	}
	lockLoggerMockProviderSubcriptionFailed.RLock()
	calls = mock.calls.ProviderSubcriptionFailed
	lockLoggerMockProviderSubcriptionFailed.RUnlock()
	return calls
}

// ServerActionPublish calls ServerActionPublishFunc.
func (mock *LoggerMock) ServerActionPublish(in1 *pipe.Pipe, in2 *providers.Message) {
	if mock.ServerActionPublishFunc == nil {
		panic("moq: LoggerMock.ServerActionPublishFunc is nil but Logger.ServerActionPublish was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *providers.Message
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockServerActionPublish.Lock()
	mock.calls.ServerActionPublish = append(mock.calls.ServerActionPublish, callInfo)
	lockLoggerMockServerActionPublish.Unlock()
	mock.ServerActionPublishFunc(in1, in2)
}

// ServerActionPublishCalls gets all the calls that were made to ServerActionPublish.
// Check the length with:
//     len(mockedLogger.ServerActionPublishCalls())
func (mock *LoggerMock) ServerActionPublishCalls() []struct {
	In1 *pipe.Pipe
	In2 *providers.Message
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *providers.Message
	}
	lockLoggerMockServerActionPublish.RLock()
	calls = mock.calls.ServerActionPublish
	lockLoggerMockServerActionPublish.RUnlock()
	return calls
}

// ServerActionPublishFailed calls ServerActionPublishFailedFunc.
func (mock *LoggerMock) ServerActionPublishFailed(in1 *pipe.Pipe, in2 *providers.Message, in3 error) {
	if mock.ServerActionPublishFailedFunc == nil {
		panic("moq: LoggerMock.ServerActionPublishFailedFunc is nil but Logger.ServerActionPublishFailed was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *providers.Message
		In3 error
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockLoggerMockServerActionPublishFailed.Lock()
	mock.calls.ServerActionPublishFailed = append(mock.calls.ServerActionPublishFailed, callInfo)
	lockLoggerMockServerActionPublishFailed.Unlock()
	mock.ServerActionPublishFailedFunc(in1, in2, in3)
}

// ServerActionPublishFailedCalls gets all the calls that were made to ServerActionPublishFailed.
// Check the length with:
//     len(mockedLogger.ServerActionPublishFailedCalls())
func (mock *LoggerMock) ServerActionPublishFailedCalls() []struct {
	In1 *pipe.Pipe
	In2 *providers.Message
	In3 error
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *providers.Message
		In3 error
	}
	lockLoggerMockServerActionPublishFailed.RLock()
	calls = mock.calls.ServerActionPublishFailed
	lockLoggerMockServerActionPublishFailed.RUnlock()
	return calls
}

// ServerActionPublishSuccess calls ServerActionPublishSuccessFunc.
func (mock *LoggerMock) ServerActionPublishSuccess(in1 *pipe.Pipe, in2 *providers.Message) {
	if mock.ServerActionPublishSuccessFunc == nil {
		panic("moq: LoggerMock.ServerActionPublishSuccessFunc is nil but Logger.ServerActionPublishSuccess was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *providers.Message
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockServerActionPublishSuccess.Lock()
	mock.calls.ServerActionPublishSuccess = append(mock.calls.ServerActionPublishSuccess, callInfo)
	lockLoggerMockServerActionPublishSuccess.Unlock()
	mock.ServerActionPublishSuccessFunc(in1, in2)
}

// ServerActionPublishSuccessCalls gets all the calls that were made to ServerActionPublishSuccess.
// Check the length with:
//     len(mockedLogger.ServerActionPublishSuccessCalls())
func (mock *LoggerMock) ServerActionPublishSuccessCalls() []struct {
	In1 *pipe.Pipe
	In2 *providers.Message
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *providers.Message
	}
	lockLoggerMockServerActionPublishSuccess.RLock()
	calls = mock.calls.ServerActionPublishSuccess
	lockLoggerMockServerActionPublishSuccess.RUnlock()
	return calls
}

// ServerFailPublish calls ServerFailPublishFunc.
func (mock *LoggerMock) ServerFailPublish(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message) {
	if mock.ServerFailPublishFunc == nil {
		panic("moq: LoggerMock.ServerFailPublishFunc is nil but Logger.ServerFailPublish was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockLoggerMockServerFailPublish.Lock()
	mock.calls.ServerFailPublish = append(mock.calls.ServerFailPublish, callInfo)
	lockLoggerMockServerFailPublish.Unlock()
	mock.ServerFailPublishFunc(in1, in2, in3)
}

// ServerFailPublishCalls gets all the calls that were made to ServerFailPublish.
// Check the length with:
//     len(mockedLogger.ServerFailPublishCalls())
func (mock *LoggerMock) ServerFailPublishCalls() []struct {
	In1 *pipe.Pipe
	In2 *pipe.Action
	In3 *providers.Message
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
	}
	lockLoggerMockServerFailPublish.RLock()
	calls = mock.calls.ServerFailPublish
	lockLoggerMockServerFailPublish.RUnlock()
	return calls
}

// ServerFailPublishFailed calls ServerFailPublishFailedFunc.
func (mock *LoggerMock) ServerFailPublishFailed(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message, in4 error) {
	if mock.ServerFailPublishFailedFunc == nil {
		panic("moq: LoggerMock.ServerFailPublishFailedFunc is nil but Logger.ServerFailPublishFailed was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
		In4 error
	}{
		In1: in1,
		In2: in2,
		In3: in3,
		In4: in4,
	}
	lockLoggerMockServerFailPublishFailed.Lock()
	mock.calls.ServerFailPublishFailed = append(mock.calls.ServerFailPublishFailed, callInfo)
	lockLoggerMockServerFailPublishFailed.Unlock()
	mock.ServerFailPublishFailedFunc(in1, in2, in3, in4)
}

// ServerFailPublishFailedCalls gets all the calls that were made to ServerFailPublishFailed.
// Check the length with:
//     len(mockedLogger.ServerFailPublishFailedCalls())
func (mock *LoggerMock) ServerFailPublishFailedCalls() []struct {
	In1 *pipe.Pipe
	In2 *pipe.Action
	In3 *providers.Message
	In4 error
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
		In4 error
	}
	lockLoggerMockServerFailPublishFailed.RLock()
	calls = mock.calls.ServerFailPublishFailed
	lockLoggerMockServerFailPublishFailed.RUnlock()
	return calls
}

// ServerFailPublishSuccess calls ServerFailPublishSuccessFunc.
func (mock *LoggerMock) ServerFailPublishSuccess(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message) {
	if mock.ServerFailPublishSuccessFunc == nil {
		panic("moq: LoggerMock.ServerFailPublishSuccessFunc is nil but Logger.ServerFailPublishSuccess was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockLoggerMockServerFailPublishSuccess.Lock()
	mock.calls.ServerFailPublishSuccess = append(mock.calls.ServerFailPublishSuccess, callInfo)
	lockLoggerMockServerFailPublishSuccess.Unlock()
	mock.ServerFailPublishSuccessFunc(in1, in2, in3)
}

// ServerFailPublishSuccessCalls gets all the calls that were made to ServerFailPublishSuccess.
// Check the length with:
//     len(mockedLogger.ServerFailPublishSuccessCalls())
func (mock *LoggerMock) ServerFailPublishSuccessCalls() []struct {
	In1 *pipe.Pipe
	In2 *pipe.Action
	In3 *providers.Message
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
	}
	lockLoggerMockServerFailPublishSuccess.RLock()
	calls = mock.calls.ServerFailPublishSuccess
	lockLoggerMockServerFailPublishSuccess.RUnlock()
	return calls
}

// ServerHandleMessageExpired calls ServerHandleMessageExpiredFunc.
func (mock *LoggerMock) ServerHandleMessageExpired(in1 *pipe.Pipe, in2 *providers.Message) {
	if mock.ServerHandleMessageExpiredFunc == nil {
		panic("moq: LoggerMock.ServerHandleMessageExpiredFunc is nil but Logger.ServerHandleMessageExpired was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *providers.Message
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockServerHandleMessageExpired.Lock()
	mock.calls.ServerHandleMessageExpired = append(mock.calls.ServerHandleMessageExpired, callInfo)
	lockLoggerMockServerHandleMessageExpired.Unlock()
	mock.ServerHandleMessageExpiredFunc(in1, in2)
}

// ServerHandleMessageExpiredCalls gets all the calls that were made to ServerHandleMessageExpired.
// Check the length with:
//     len(mockedLogger.ServerHandleMessageExpiredCalls())
func (mock *LoggerMock) ServerHandleMessageExpiredCalls() []struct {
	In1 *pipe.Pipe
	In2 *providers.Message
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *providers.Message
	}
	lockLoggerMockServerHandleMessageExpired.RLock()
	calls = mock.calls.ServerHandleMessageExpired
	lockLoggerMockServerHandleMessageExpired.RUnlock()
	return calls
}

// ServerNewMessageReceivedStart calls ServerNewMessageReceivedStartFunc.
func (mock *LoggerMock) ServerNewMessageReceivedStart(in1 *pipe.Pipe, in2 *providers.Message) *LoggerTiming {
	if mock.ServerNewMessageReceivedStartFunc == nil {
		panic("moq: LoggerMock.ServerNewMessageReceivedStartFunc is nil but Logger.ServerNewMessageReceivedStart was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *providers.Message
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockServerNewMessageReceivedStart.Lock()
	mock.calls.ServerNewMessageReceivedStart = append(mock.calls.ServerNewMessageReceivedStart, callInfo)
	lockLoggerMockServerNewMessageReceivedStart.Unlock()
	return mock.ServerNewMessageReceivedStartFunc(in1, in2)
}

// ServerNewMessageReceivedStartCalls gets all the calls that were made to ServerNewMessageReceivedStart.
// Check the length with:
//     len(mockedLogger.ServerNewMessageReceivedStartCalls())
func (mock *LoggerMock) ServerNewMessageReceivedStartCalls() []struct {
	In1 *pipe.Pipe
	In2 *providers.Message
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *providers.Message
	}
	lockLoggerMockServerNewMessageReceivedStart.RLock()
	calls = mock.calls.ServerNewMessageReceivedStart
	lockLoggerMockServerNewMessageReceivedStart.RUnlock()
	return calls
}

// ServerNoPipesConfigured calls ServerNoPipesConfiguredFunc.
func (mock *LoggerMock) ServerNoPipesConfigured(in1 providers.Provider) {
	if mock.ServerNoPipesConfiguredFunc == nil {
		panic("moq: LoggerMock.ServerNoPipesConfiguredFunc is nil but Logger.ServerNoPipesConfigured was just called")
	}
	callInfo := struct {
		In1 providers.Provider
	}{
		In1: in1,
	}
	lockLoggerMockServerNoPipesConfigured.Lock()
	mock.calls.ServerNoPipesConfigured = append(mock.calls.ServerNoPipesConfigured, callInfo)
	lockLoggerMockServerNoPipesConfigured.Unlock()
	mock.ServerNoPipesConfiguredFunc(in1)
}

// ServerNoPipesConfiguredCalls gets all the calls that were made to ServerNoPipesConfigured.
// Check the length with:
//     len(mockedLogger.ServerNoPipesConfiguredCalls())
func (mock *LoggerMock) ServerNoPipesConfiguredCalls() []struct {
	In1 providers.Provider
} {
	var calls []struct {
		In1 providers.Provider
	}
	lockLoggerMockServerNoPipesConfigured.RLock()
	calls = mock.calls.ServerNoPipesConfigured
	lockLoggerMockServerNoPipesConfigured.RUnlock()
	return calls
}

// ServerSuccessPublish calls ServerSuccessPublishFunc.
func (mock *LoggerMock) ServerSuccessPublish(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message) {
	if mock.ServerSuccessPublishFunc == nil {
		panic("moq: LoggerMock.ServerSuccessPublishFunc is nil but Logger.ServerSuccessPublish was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockLoggerMockServerSuccessPublish.Lock()
	mock.calls.ServerSuccessPublish = append(mock.calls.ServerSuccessPublish, callInfo)
	lockLoggerMockServerSuccessPublish.Unlock()
	mock.ServerSuccessPublishFunc(in1, in2, in3)
}

// ServerSuccessPublishCalls gets all the calls that were made to ServerSuccessPublish.
// Check the length with:
//     len(mockedLogger.ServerSuccessPublishCalls())
func (mock *LoggerMock) ServerSuccessPublishCalls() []struct {
	In1 *pipe.Pipe
	In2 *pipe.Action
	In3 *providers.Message
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
	}
	lockLoggerMockServerSuccessPublish.RLock()
	calls = mock.calls.ServerSuccessPublish
	lockLoggerMockServerSuccessPublish.RUnlock()
	return calls
}

// ServerSuccessPublishFailed calls ServerSuccessPublishFailedFunc.
func (mock *LoggerMock) ServerSuccessPublishFailed(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message, in4 error) {
	if mock.ServerSuccessPublishFailedFunc == nil {
		panic("moq: LoggerMock.ServerSuccessPublishFailedFunc is nil but Logger.ServerSuccessPublishFailed was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
		In4 error
	}{
		In1: in1,
		In2: in2,
		In3: in3,
		In4: in4,
	}
	lockLoggerMockServerSuccessPublishFailed.Lock()
	mock.calls.ServerSuccessPublishFailed = append(mock.calls.ServerSuccessPublishFailed, callInfo)
	lockLoggerMockServerSuccessPublishFailed.Unlock()
	mock.ServerSuccessPublishFailedFunc(in1, in2, in3, in4)
}

// ServerSuccessPublishFailedCalls gets all the calls that were made to ServerSuccessPublishFailed.
// Check the length with:
//     len(mockedLogger.ServerSuccessPublishFailedCalls())
func (mock *LoggerMock) ServerSuccessPublishFailedCalls() []struct {
	In1 *pipe.Pipe
	In2 *pipe.Action
	In3 *providers.Message
	In4 error
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
		In4 error
	}
	lockLoggerMockServerSuccessPublishFailed.RLock()
	calls = mock.calls.ServerSuccessPublishFailed
	lockLoggerMockServerSuccessPublishFailed.RUnlock()
	return calls
}

// ServerSuccessPublishSuccess calls ServerSuccessPublishSuccessFunc.
func (mock *LoggerMock) ServerSuccessPublishSuccess(in1 *pipe.Pipe, in2 *pipe.Action, in3 *providers.Message) {
	if mock.ServerSuccessPublishSuccessFunc == nil {
		panic("moq: LoggerMock.ServerSuccessPublishSuccessFunc is nil but Logger.ServerSuccessPublishSuccess was just called")
	}
	callInfo := struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockLoggerMockServerSuccessPublishSuccess.Lock()
	mock.calls.ServerSuccessPublishSuccess = append(mock.calls.ServerSuccessPublishSuccess, callInfo)
	lockLoggerMockServerSuccessPublishSuccess.Unlock()
	mock.ServerSuccessPublishSuccessFunc(in1, in2, in3)
}

// ServerSuccessPublishSuccessCalls gets all the calls that were made to ServerSuccessPublishSuccess.
// Check the length with:
//     len(mockedLogger.ServerSuccessPublishSuccessCalls())
func (mock *LoggerMock) ServerSuccessPublishSuccessCalls() []struct {
	In1 *pipe.Pipe
	In2 *pipe.Action
	In3 *providers.Message
} {
	var calls []struct {
		In1 *pipe.Pipe
		In2 *pipe.Action
		In3 *providers.Message
	}
	lockLoggerMockServerSuccessPublishSuccess.RLock()
	calls = mock.calls.ServerSuccessPublishSuccess
	lockLoggerMockServerSuccessPublishSuccess.RUnlock()
	return calls
}

// ServerTemplateProcessFail calls ServerTemplateProcessFailFunc.
func (mock *LoggerMock) ServerTemplateProcessFail(in1 *pipe.Action, in2 []byte, in3 error) {
	if mock.ServerTemplateProcessFailFunc == nil {
		panic("moq: LoggerMock.ServerTemplateProcessFailFunc is nil but Logger.ServerTemplateProcessFail was just called")
	}
	callInfo := struct {
		In1 *pipe.Action
		In2 []byte
		In3 error
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockLoggerMockServerTemplateProcessFail.Lock()
	mock.calls.ServerTemplateProcessFail = append(mock.calls.ServerTemplateProcessFail, callInfo)
	lockLoggerMockServerTemplateProcessFail.Unlock()
	mock.ServerTemplateProcessFailFunc(in1, in2, in3)
}

// ServerTemplateProcessFailCalls gets all the calls that were made to ServerTemplateProcessFail.
// Check the length with:
//     len(mockedLogger.ServerTemplateProcessFailCalls())
func (mock *LoggerMock) ServerTemplateProcessFailCalls() []struct {
	In1 *pipe.Action
	In2 []byte
	In3 error
} {
	var calls []struct {
		In1 *pipe.Action
		In2 []byte
		In3 error
	}
	lockLoggerMockServerTemplateProcessFail.RLock()
	calls = mock.calls.ServerTemplateProcessFail
	lockLoggerMockServerTemplateProcessFail.RUnlock()
	return calls
}

// ServerTemplateProcessStart calls ServerTemplateProcessStartFunc.
func (mock *LoggerMock) ServerTemplateProcessStart(in1 *pipe.Action, in2 []byte) *LoggerTiming {
	if mock.ServerTemplateProcessStartFunc == nil {
		panic("moq: LoggerMock.ServerTemplateProcessStartFunc is nil but Logger.ServerTemplateProcessStart was just called")
	}
	callInfo := struct {
		In1 *pipe.Action
		In2 []byte
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockServerTemplateProcessStart.Lock()
	mock.calls.ServerTemplateProcessStart = append(mock.calls.ServerTemplateProcessStart, callInfo)
	lockLoggerMockServerTemplateProcessStart.Unlock()
	return mock.ServerTemplateProcessStartFunc(in1, in2)
}

// ServerTemplateProcessStartCalls gets all the calls that were made to ServerTemplateProcessStart.
// Check the length with:
//     len(mockedLogger.ServerTemplateProcessStartCalls())
func (mock *LoggerMock) ServerTemplateProcessStartCalls() []struct {
	In1 *pipe.Action
	In2 []byte
} {
	var calls []struct {
		In1 *pipe.Action
		In2 []byte
	}
	lockLoggerMockServerTemplateProcessStart.RLock()
	calls = mock.calls.ServerTemplateProcessStart
	lockLoggerMockServerTemplateProcessStart.RUnlock()
	return calls
}

// ServerTemplateProcessSuccess calls ServerTemplateProcessSuccessFunc.
func (mock *LoggerMock) ServerTemplateProcessSuccess(in1 *pipe.Action, in2 []byte) {
	if mock.ServerTemplateProcessSuccessFunc == nil {
		panic("moq: LoggerMock.ServerTemplateProcessSuccessFunc is nil but Logger.ServerTemplateProcessSuccess was just called")
	}
	callInfo := struct {
		In1 *pipe.Action
		In2 []byte
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockServerTemplateProcessSuccess.Lock()
	mock.calls.ServerTemplateProcessSuccess = append(mock.calls.ServerTemplateProcessSuccess, callInfo)
	lockLoggerMockServerTemplateProcessSuccess.Unlock()
	mock.ServerTemplateProcessSuccessFunc(in1, in2)
}

// ServerTemplateProcessSuccessCalls gets all the calls that were made to ServerTemplateProcessSuccess.
// Check the length with:
//     len(mockedLogger.ServerTemplateProcessSuccessCalls())
func (mock *LoggerMock) ServerTemplateProcessSuccessCalls() []struct {
	In1 *pipe.Action
	In2 []byte
} {
	var calls []struct {
		In1 *pipe.Action
		In2 []byte
	}
	lockLoggerMockServerTemplateProcessSuccess.RLock()
	calls = mock.calls.ServerTemplateProcessSuccess
	lockLoggerMockServerTemplateProcessSuccess.RUnlock()
	return calls
}

// ServerUnableToListen calls ServerUnableToListenFunc.
func (mock *LoggerMock) ServerUnableToListen(in1 providers.Provider, in2 error) {
	if mock.ServerUnableToListenFunc == nil {
		panic("moq: LoggerMock.ServerUnableToListenFunc is nil but Logger.ServerUnableToListen was just called")
	}
	callInfo := struct {
		In1 providers.Provider
		In2 error
	}{
		In1: in1,
		In2: in2,
	}
	lockLoggerMockServerUnableToListen.Lock()
	mock.calls.ServerUnableToListen = append(mock.calls.ServerUnableToListen, callInfo)
	lockLoggerMockServerUnableToListen.Unlock()
	mock.ServerUnableToListenFunc(in1, in2)
}

// ServerUnableToListenCalls gets all the calls that were made to ServerUnableToListen.
// Check the length with:
//     len(mockedLogger.ServerUnableToListenCalls())
func (mock *LoggerMock) ServerUnableToListenCalls() []struct {
	In1 providers.Provider
	In2 error
} {
	var calls []struct {
		In1 providers.Provider
		In2 error
	}
	lockLoggerMockServerUnableToListen.RLock()
	calls = mock.calls.ServerUnableToListen
	lockLoggerMockServerUnableToListen.RUnlock()
	return calls
}
